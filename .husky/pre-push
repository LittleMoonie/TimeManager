#!/usr/bin/env bash
# üß± Husky pre-push hook ‚Äî GoGoTime Monorepo
# Blocks pushes to or from protected branches unless ALLOW_PROTECTED_PUSH=1

[ -z "${BASH_VERSION:-}" ] && exec /usr/bin/env bash "$0" "$@"
set -Eeuo pipefail

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
red()  { printf "\033[31m%s\033[0m\n" "$*"; }
grn()  { printf "\033[32m%s\033[0m\n" "$*"; }
ylw()  { printf "\033[33m%s\033[0m\n" "$*"; }
blu()  { printf "\033[34m%s\033[0m\n" "$*"; }
abort(){ red "‚ùå $*"; exit 1; }
note() { blu "‚ÑπÔ∏è  $*"; }
ok()   { grn "‚úÖ $*"; }

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Keep only branch names here (not origin/*)
PROTECTED=("main" "develop")
BYPASS="${ALLOW_PROTECTED_PUSH:-0}"

echo ""
blu "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
blu "üîí  GoGoTime Push Protection"
blu "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
echo ""
note "Checking push target for protected branches..."

REMOTE_NAME="${1:-origin}"   # arg1 = remote name
# arg2 is the remote URL; DO NOT assume it‚Äôs a branch!

CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo HEAD)"
UPSTREAM_FULL="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
UPSTREAM_BRANCH="${UPSTREAM_FULL#*/}" # strips 'origin/' if present

is_protected() {
  local name="$1"
  for p in "${PROTECTED[@]}"; do
    [[ "$name" == "$p" ]] && return 0
  done
  return 1
}

BLOCK=0

# üîí Paranoid mode ‚Äî block any push mentioning protected branches, even if no updates
for arg in "$@"; do
  for p in "${PROTECTED[@]}"; do
    if [[ "$arg" =~ (^|[:/])$p($|[[:space:]]) ]]; then
      red "‚ùå Push blocked: command references protected branch '$p' (even no-op)."
      blu "   Use a Pull Request instead."
      echo ""
      exit 1
    fi
  done
done



# 1Ô∏è‚É£  Block pushes *from* protected local branches
if is_protected "$CURRENT_BRANCH"; then
  red "‚ùå Push blocked: you are on protected branch '$CURRENT_BRANCH'"
  echo "   Please create a feature branch and open a PR."
  BLOCK=1
fi

# 2Ô∏è‚É£  Read STDIN for refspecs the push intends to update
#     Lines: <local ref> <local sha> <remote ref> <remote sha>
stdin_seen=0
while read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA; do
  stdin_seen=1

  # Only continue if the remote ref looks like a branch
  if [[ "$REMOTE_REF" =~ ^refs/heads/([^[:space:]]+)$ ]]; then
    target="${BASH_REMATCH[1]}"

    if is_protected "$target"; then
      # Also block deletes (REMOTE_SHA = all zeros)
      if [[ "$REMOTE_SHA" =~ ^0+$ ]]; then
        red "‚ùå Push blocked: deletion of protected branch '$target' is forbidden"
      else
        red "‚ùå Push blocked: remote target '$target' is protected"
      fi
      BLOCK=1
    fi
  fi
done < <(cat)  # ensures no "unbound variable" when no match

b="$(git rev-parse --abbrev-ref HEAD)"; case "$b" in
  main|develop) echo "‚ùå No commits on $b. Use a feature branch."; exit 1;;
esac

# 3Ô∏è‚É£  If there were NO ref lines on STDIN (e.g., nothing to push),
#     fall back to upstream inference: block if upstream is protected.
if [[ "$stdin_seen" -eq 0 && -n "$UPSTREAM_BRANCH" ]] && is_protected "$UPSTREAM_BRANCH"; then
  red "‚ùå Push blocked: upstream '$UPSTREAM_BRANCH' is protected"
  echo "   This includes 'git push' with default upstream set to a protected branch."
  BLOCK=1
fi

# 4Ô∏è‚É£  Final decision
if [[ "$BLOCK" -eq 1 ]]; then
  if [[ "$BYPASS" == "1" ]]; then
    ylw "‚ö†Ô∏è  Bypass enabled (ALLOW_PROTECTED_PUSH=1). Proceeding anyway."
    exit 0
  fi
  echo ""
  red "üõë Push cancelled ‚Äî protected branch detected."
  blu "   Use a Pull Request instead."
  echo ""
  exit 1
fi

ok "No protected branches targeted. Safe to push."
echo ""
exit 0
